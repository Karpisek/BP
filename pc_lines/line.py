import cv2
import numpy as np

import constants


class SamePointError(Exception):
    pass


class NoIntersectionError(Exception):
    pass


class NotOnLineError(Exception):
    pass


def ransac(creator_points, voting_points, ransac_threshold, write=False):
    """
    Implementation of RANSAC algorithm for computing line from given points.

    :param creator_points: points used for line creating
    :param voting_points: points used for voting for best line
    :param ransac_threshold: max distance of voting points for selecting line
    :param write: if debug info should be writen to file
    :return: (detected line, number of votes)
    """

    best_line_voters = 0
    best_line_average_distance = np.inf
    best_line = None

    if write:
        with open("/Users/miro/Desktop/ransac.txt", "w") as file:
            for index, point in enumerate(creator_points):
                x, y = point

                x = int(x)
                y = int(y)

                if x > 0:
                    file.write(f"\n\\coordinate (c{index}) at ({x}/1024 * 10, {y}/1024 * 10);")
                    file.write(f"\n\\fill[blue] (c{index}) circle (5pt);")

    for point1 in creator_points:
        for point2 in creator_points:
            try:
                line = Line(point1, point2)
            except SamePointError:
                continue

            accepted_points = 0
            sum_distance = 0
            for point in voting_points:
                distance = line.point_distance(point)

                if distance < ransac_threshold:
                    accepted_points += 1
                    sum_distance += distance

            if accepted_points >= best_line_voters and accepted_points != 0:

                distance_avg = sum_distance / accepted_points
                if accepted_points > best_line_voters or distance_avg < best_line_average_distance:
                    best_line_voters = accepted_points
                    best_line_average_distance = distance_avg
                    best_line = line

    return best_line, best_line_voters


class LineDrawError(Exception):
    pass


class LineNotOnImageError(Exception):
    pass


class Line:
    """
    Line representation.
    Uses representation in form of ax + by + c = 0
    """

    @staticmethod
    def horizontal_line():
        """
        :return: new generated horizontal line
        """

        return Line((1, 0), (0, 0))

    def __init__(self, point1, point2=None, direction=None):
        """
        Two ways to generate new line: select both points or select first point and direction vector.

        :param point1: first point
        :param point2: second point
        :param direction: direction vector
        :raise SamePointError if both given points are the same
        """

        if point1 == point2:
            raise SamePointError

        if point2 is None and direction is None:
            raise SamePointError
        
        x1, y1 = point1

        if point2 is not None:
            x2, y2 = point2

            dx = x2 - x1
            dy = y2 - y1

        else:
            dx, dy = direction

        self._origin = [x1, y1]
        self._direction = [dx, dy]

        if self.direction[1] == 0:
            coef = (self.direction[1] / self.direction[0])
            self.a = round(-coef, 3)
            self.b = 1
            self.c = round(-(self.origin[1] - self.origin[0] * coef), 3)

        else:
            coef = (self.direction[0] / self.direction[1])
            self.a = 1
            self.b = round(-coef, 3)
            self.c = round(-(self.origin[0] - self.origin[1] * coef), 3)

    @property
    def origin(self) -> [float, float]:
        """
        :return: firs point given to the ine
        """

        return self._origin

    @property
    def direction(self) -> [float, float]:
        """
        :return: direction vector of the line
        """

        return self._direction

    @property
    def horizontal(self) -> bool:
        """
        :return: if the line is horizontal
        """

        return self.direction[1] == 0

    @property
    def vertical(self) -> bool:
        """
        :return: if the line is vertical
        """

        return self.direction[0] == 0

    @property
    def magnitude(self) -> float:
        """
        Assuming that line was generated from two points. May lead to error when used
        on line generated by direction.

        :return: magnitude of the line
        """

        return np.sqrt(self.direction[0] ** 2 + self.direction[1] ** 2)

    def normal_direction(self) -> (float, float):
        """
        :return: normal vector direction to this lien
        """

        return self.a, self.b

    def angle(self, line2) -> float:
        """
        Smallest angle between two lines

        :param line2: second line
        :return: angle
        """

        if np.dot(self.direction, line2.direction) == 0:
            angle = 90.

        else:
            cos_alpha = np.dot(self.direction, line2.direction) / (self.magnitude * line2.magnitude)

            if cos_alpha > 1:
                cos_alpha = 1

            elif cos_alpha < -1:
                cos_alpha = -1

            angle = np.degrees(np.arccos(cos_alpha))

        return angle

    def parallel(self, line2) -> bool:
        """
        Checks if two lines are parallel

        :param line2: line to compare
        :return: if are parallel
        """

        return self.angle(line2) == 0 or self.angle(line2) == 180

    def intersection(self, line2) -> (float, float):
        """
        Calculates intersection point of two lines

        :param line2: line to intersect
        :return: intersection point
        :raise NoIntersectionError if no intersection is found
        """

        a = np.array([
            [self.a, self.b],
            [line2.a, line2.b]
        ])

        b = np.array([
            [-self.c],
            [-line2.c]
        ])

        try:
            solved = np.linalg.solve(a, b)
        except np.linalg.LinAlgError:
            raise NoIntersectionError

        return solved[0][0], solved[1][0]

    # def line_distance(self, line) -> float:
    #     """
    #     Calculates distance from line
    #
    #     :param line:
    #     :return:
    #     """
    #     point = self.origin[0], self.origin[1]
    #     return line.point_distance(point)

    def point_distance(self, point) -> float:
        """
        Calculates distance of point from line.

        :param point: selected point
        :return: distance
        """

        x, y = point

        return np.abs(self.a * x + self.b * y + self.c)/np.sqrt(self.a ** 2 + self.b ** 2)

    def general_equation(self) -> (float, float, float):
        """
        :return: a, b, c coefs of general equation ax + by + c = 0
        """
        # ax + by + c = 0
        return self.a, self.b, self.c

    def on_line(self, point) -> bool:
        """
        :param point: selected point
        :return: if selected point is on line
        """

        x, y = point

        return self.a * x + self.b * y + self.c == 0

    def find_coordinate(self, x=None, y=None) -> (float, float):
        """
        Finds coordinate pair for given coordinate.

        :raise NotOnLineError when not possible to find a pair coordinate (horizontal or vertical line)
        :param x: x coordinate to pair
        :param y: y coordinate to pair
        :return: point on line to generated by selected coordinate
        """

        if y is None and x is None:
            return None

        if x is not None:
            if self.b == 0:
                raise NotOnLineError
            return x, ((-self.a) * x - self.c) / self.b
        else:
            if self.a == 0:
                raise NotOnLineError
            return ((-self.b) * y - self.c) / self.a, y

    def edge_points(self, info):
        """
        Calculates intersection of this line with given frame height and width assuming that 0,0 coordinates
        are in the left top corner.

        :param info: instance of InputInfo containing width and height of frame
        :return: all intersections of line with selected frame
        """

        edge_points = []
        edge_coordinates = [(None, 0), (0, None), (None, info.height - 1), (info.width - 1, None)]

        for coordinate in edge_coordinates:
            try:
                new_point = ([int(cord) for cord in self.find_coordinate(*coordinate)])

                if 0 <= new_point[0] < info.width and 0 <= new_point[1] < info.height:
                    edge_points.append(new_point)

            except NotOnLineError:
                continue

        return edge_points

    def draw(self, image, color, thickness) -> None:
        """
        Helper method to draw this line on selected image

        :param image: selected image
        :param color: color to draw
        :param thickness: thickness to draw
        :return: updated image
        """

        if len(image.shape) == 3:
            h, w, _ = image.shape
        elif len(image.shape) == 2:
            h, w = image.shape
        else:
            raise LineDrawError

        try:
            p1 = [int(cord) for cord in self.find_coordinate(y=0)]
            p2 = [int(cord) for cord in self.find_coordinate(y=h)]

        except NotOnLineError:
            p1 = [int(cord) for cord in self.find_coordinate(x=0)]
            p2 = [int(cord) for cord in self.find_coordinate(x=w)]

        p1 = int(np.clip(p1[0], constants.UINT_MIN, constants.UINT_MAX)), int(np.clip(p1[1], constants.UINT_MIN, constants.UINT_MAX))
        p2 = int(np.clip(p2[0], constants.UINT_MIN, constants.UINT_MAX)), int(np.clip(p2[1], constants.UINT_MIN, constants.UINT_MAX))

        cv2.line(image, tuple(p1), tuple(p2), color, thickness)

    def serialize(self):
        """
        Method used for serializing line

        :return: dictionary serialized line
        """

        return {"origin": (int(self.origin[0]), int(self.origin[1])),
                "direction": (int(self.direction[0]), int(self.direction[1]))}

    def __str__(self):
        return f'{self.a}x + {self.b}y + {self.c} = 0'
